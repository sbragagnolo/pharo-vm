primitive generators
compilePrimitive
	"Compile a primitive.  If possible, performance-critical primtiives will
	 be generated by their own routines (primitiveGenerator).  Otherwise,
	 if there is a primitive at all, we call the C routine with the usual
	 stack-switching dance, test the primFailCode and then either return
	 on success or continue to the method body."
	<inline: false>
	| code opcodeIndexAtPrimitive primitiveDescriptor primitiveRoutine |
	<var: #primitiveDescriptor type: #'PrimitiveDescriptor *'>
	<var: #primitiveRoutine declareC: 'void (*primitiveRoutine)(void)'>
	primitiveIndex = 0 ifTrue: [^0].
	code := 0.
	"Note opcodeIndex so that compileFallbackToInterpreterPrimitive:
	 can discard arg load instructions for unimplemented primitives."
	opcodeIndexAtPrimitive := opcodeIndex.
	"If a descriptor specifies an argument count (by numArgs >= 0) then it must match
	 for the generated code to be correct.  For example for speed many primitives use
	 ResultReceiverReg instead of accessing the stack, so the receiver better be at
	 numArgs down the stack.  Use the interpreter version if not."
	((primitiveDescriptor := self primitiveGeneratorOrNil) notNil
	 and: [primitiveDescriptor primitiveGenerator notNil
	 and: [(primitiveDescriptor primNumArgs < 0 "means don't care"
		   or: [primitiveDescriptor primNumArgs = (coInterpreter argumentCountOf: methodObj)])]]) ifTrue:
		[code := objectRepresentation perform: primitiveDescriptor primitiveGenerator].
	(code < 0 and: [code ~= UnimplementedPrimitive]) ifTrue: "Generator failed, so no point continuing..."
		[^code].
	code = UnfailingPrimitive ifTrue:
		[^0].
	"If the machine code verison handles all cases the only reason to call the interpreter
	 primitive is to reap the primitive error code.  Don't bother if it isn't used."
	(code = CompletePrimitive
	 and: [(self methodUsesPrimitiveErrorCode: methodObj header: methodHeader) not]) ifTrue:
		[^0].
	"Discard any arg load code generated by the primitive generator."
	code = UnimplementedPrimitive ifTrue:
		[opcodeIndex := opcodeIndexAtPrimitive].
	((primitiveRoutine := coInterpreter
							functionPointerForCompiledMethod: methodObj
							primitiveIndex: primitiveIndex) isNil "no primitive"
	or: [primitiveRoutine = (coInterpreter functionPointerFor: 0 inClass: nil) "routine = primitiveFail"]) ifTrue:
		[^self genFastPrimFail].
	minValidCallAddress := minValidCallAddress min: primitiveRoutine asUnsignedInteger.
	^self compileInterpreterPrimitive: primitiveRoutine