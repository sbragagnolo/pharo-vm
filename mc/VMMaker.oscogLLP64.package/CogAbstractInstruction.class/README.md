I am an abstract instruction generated by the Cogit.  I am subsequently concretized to machine code for the current processor.  A sequence of concretized CogAbstractInstructions are concatenated to form the code for a CogMethod.  I am an abstract class.  My concrete subclasses concretize to the machine code of a specific processor.

Instance Variables
	address:			<Integer>
	bcpc:				<Integer>
	cogit:				<Cogit>
	dependent:			<AbstractInstruction|nil>
	machineCode:		<CArray on: (ByteArray|Array)>
	machineCodeSize:	<Integer>
	maxSize:			<Integer>
	objectMemory:		<NewCoObjectMemory|SpurCoMemoryManager etc>
	opcode:			<Integer>
	operands:			<CArray on: Array>

address
	- the address at which the instruction will be generated

bcpc
	- the bytecode pc for which the instruction was generated; simulation only

cogit
	- the Cogit assembling the receiver; simulation only

dependent
	- a reference to another instruction which depends on the receiver, if any; in C this is a pointer

machineCode
	- the array of machine code the receiver generates when concretized

machineCodeSize
	- the size of machineCode in bytes

maxSize
	- the maximum size of machine code that the current instruction will generate, in bytes

objectMemory
	- the memory manager for the system; simulation only

opcode
	- the opcode for the receiver which defines which abstract opcode it represents; see CogRTLOpcodes class>>initialize and CogAbstractInstruction subclass initialize methods

operands
	- the array containing any operands the instruction may have; the opcode defines implicitly how many operands are consdered